[
  {
    "type": "function",
    "name": "control_temperature_system",
    "docstring": null,
    "code": "def control_temperature_system(mode, temperature):\n    try:\n        result = subprocess.run(['python', './HeaterCooler.py', 'set', 'a', mode, str(temperature)], capture_output=True, text=True)\n        return result.stdout\n    except Exception as e:\n        return str(e)"
  },
  {
    "type": "function",
    "name": "get_command",
    "docstring": null,
    "code": "def get_command(arg1, arg2):\n    print(\"Get command executed with args:\", arg1, arg2)"
  },
  {
    "type": "function",
    "name": "set_light_state",
    "docstring": null,
    "code": "def set_light_state(light_state):\n    try:\n        if light_state == 1:\n            print(\"Turning on the light...\")\n            subprocess.run(['python3', '/var/lib/homebridge/irrp.py', '-p', '-g17', '-f', 'codes', 'light:on'], check=True)\n        elif light_state == 0:\n            print(\"Turning off the light...\")\n            subprocess.run(['python3', '/var/lib/homebridge/irrp.py', '-p', '-g17', '-f', 'codes', 'light:off'], check=True)\n        else:\n            raise ValueError(\"Invalid light state. Use 0 to turn off or 1 to turn on.\")\n    except subprocess.CalledProcessError as e:\n        print(f\"An error occurred while trying to change the light state: {e}\")\n        raise"
  },
  {
    "type": "function",
    "name": "main",
    "docstring": null,
    "code": "def main():\n    if len(sys.argv) < 5:\n        print(\"Usage: script.py [Get|Set] <arg1> <arg2> <0|1>\")\n        sys.exit(1)\n\n    command = sys.argv[1]\n    arg1 = sys.argv[2]\n    arg2 = sys.argv[3]\n\n    try:\n        light_state = int(sys.argv[4])\n    except ValueError:\n        print(\"Invalid light state. Use 0 to turn off or 1 to turn on.\")\n        sys.exit(1)\n\n    if command == 'Get':\n        get_command(arg1, arg2)\n    elif command == 'Set':\n        set_light_state(light_state)\n    else:\n        print(\"Invalid command. Use 'Get' or 'Set'.\")\n        sys.exit(1)"
  },
  {
    "type": "function",
    "name": "control_temperature_system",
    "docstring": null,
    "code": "def control_temperature_system(mode, temperature):\n    try:\n        result = subprocess.run(['./HeaterCooler.py', mode, str(temperature)], capture_output=True, text=True)\n        return result.stdout\n    except Exception as e:\n        return str(e)"
  },
  {
    "type": "function",
    "name": "main",
    "docstring": null,
    "code": "def main():\n    # 引数の数をチェック\n    if len(sys.argv) < 5:\n        print(\"Usage: script.py [Get|Set] <arg1> <arg2> <0|1>\")\n        sys.exit(1)\n\n    command = sys.argv[1]\n    arg1 = sys.argv[2]\n    arg2 = sys.argv[3]\n\n    try:\n        light_state = int(sys.argv[4])  # 引数を整数に変換\n    except ValueError:\n        print(\"Invalid light state. Use 0 to turn off or 1 to turn on.\")\n        sys.exit(1)\n\n    if command == 'Get':\n        # Get の処理をここに追加\n        print(\"Get command executed with args:\", arg1, arg2)\n\n    elif command == 'Set':\n        try:\n            if light_state == 1:\n                print(\"Turning on the light...\")\n                subprocess.run(['python3', '/var/lib/homebridge/irrp.py', '-p', '-g17', '-f', 'codes', 'light:on'], check=True)\n            elif light_state == 0:\n                print(\"Turning off the light...\")\n                subprocess.run(['python3', '/var/lib/homebridge/irrp.py', '-p', '-g17', '-f', 'codes', 'light:off'], check=True)\n            else:\n                print(\"Invalid light state. Use 0 to turn off or 1 to turn on.\")\n                sys.exit(1)\n        except subprocess.CalledProcessError as e:\n            print(f\"An error occurred while trying to change the light state: {e}\")\n            sys.exit(1)\n    else:\n        print(\"Invalid command. Use 'Get' or 'Set'.\")\n        sys.exit(1)"
  },
  {
    "type": "function",
    "name": "backup",
    "docstring": "f -> f.bak -> f.bak1 -> f.bak2",
    "code": "def backup(f):\n   \"\"\"\n   f -> f.bak -> f.bak1 -> f.bak2\n   \"\"\"\n   try:\n      os.rename(os.path.realpath(f)+\".bak1\", os.path.realpath(f)+\".bak2\")\n   except:\n      pass\n\n   try:\n      os.rename(os.path.realpath(f)+\".bak\", os.path.realpath(f)+\".bak1\")\n   except:\n      pass\n\n   try:\n      os.rename(os.path.realpath(f), os.path.realpath(f)+\".bak\")\n   except:\n      pass"
  },
  {
    "type": "function",
    "name": "carrier",
    "docstring": "Generate carrier square wave.",
    "code": "def carrier(gpio, frequency, micros):\n   \"\"\"\n   Generate carrier square wave.\n   \"\"\"\n   wf = []\n   cycle = 1000.0 / frequency\n   cycles = int(round(micros/cycle))\n   on = int(round(cycle / 2.0))\n   sofar = 0\n   for c in range(cycles):\n      target = int(round((c+1)*cycle))\n      sofar += on\n      off = target - sofar\n      sofar += off\n      wf.append(pigpio.pulse(1<<gpio, 0, on))\n      wf.append(pigpio.pulse(0, 1<<gpio, off))\n   return wf"
  },
  {
    "type": "function",
    "name": "normalise",
    "docstring": "Typically a code will be made up of two or three distinct\nmarks (carrier) and spaces (no carrier) of different lengths.\n\nBecause of transmission and reception errors those pulses\nwhich should all be x micros long will have a variance around x.\n\nThis function identifies the distinct pulses and takes the\naverage of the lengths making up each distinct pulse.  Marks\nand spaces are processed separately.\n\nThis makes the eventual generation of waves much more efficient.\n\nInput\n\n  M    S   M   S   M   S   M    S   M    S   M\n9000 4500 600 540 620 560 590 1660 620 1690 615\n\nDistinct marks\n\n9000                average 9000\n600 620 590 620 615 average  609\n\nDistinct spaces\n\n4500                average 4500\n540 560             average  550\n1660 1690           average 1675\n\nOutput\n\n  M    S   M   S   M   S   M    S   M    S   M\n9000 4500 609 550 609 550 609 1675 609 1675 609",
    "code": "def normalise(c):\n   \"\"\"\n   Typically a code will be made up of two or three distinct\n   marks (carrier) and spaces (no carrier) of different lengths.\n\n   Because of transmission and reception errors those pulses\n   which should all be x micros long will have a variance around x.\n\n   This function identifies the distinct pulses and takes the\n   average of the lengths making up each distinct pulse.  Marks\n   and spaces are processed separately.\n\n   This makes the eventual generation of waves much more efficient.\n\n   Input\n\n     M    S   M   S   M   S   M    S   M    S   M\n   9000 4500 600 540 620 560 590 1660 620 1690 615\n\n   Distinct marks\n\n   9000                average 9000\n   600 620 590 620 615 average  609\n\n   Distinct spaces\n\n   4500                average 4500\n   540 560             average  550\n   1660 1690           average 1675\n\n   Output\n\n     M    S   M   S   M   S   M    S   M    S   M\n   9000 4500 609 550 609 550 609 1675 609 1675 609\n   \"\"\"\n   if VERBOSE:\n      print(\"before normalise\", c)\n   entries = len(c)\n   p = [0]*entries # Set all entries not processed.\n   for i in range(entries):\n      if not p[i]: # Not processed?\n         v = c[i]\n         tot = v\n         similar = 1.0\n\n         # Find all pulses with similar lengths to the start pulse.\n         for j in range(i+2, entries, 2):\n            if not p[j]: # Unprocessed.\n               if (c[j]*TOLER_MIN) < v < (c[j]*TOLER_MAX): # Similar.\n                  tot = tot + c[j]\n                  similar += 1.0\n\n         # Calculate the average pulse length.\n         newv = round(tot / similar, 2)\n         c[i] = newv\n\n         # Set all similar pulses to the average value.\n         for j in range(i+2, entries, 2):\n            if not p[j]: # Unprocessed.\n               if (c[j]*TOLER_MIN) < v < (c[j]*TOLER_MAX): # Similar.\n                  c[j] = newv\n                  p[j] = 1\n\n   if VERBOSE:\n      print(\"after normalise\", c)"
  },
  {
    "type": "function",
    "name": "compare",
    "docstring": "Check that both recodings correspond in pulse length to within\nTOLERANCE%.  If they do average the two recordings pulse lengths.\n\nInput\n\n     M    S   M   S   M   S   M    S   M    S   M\n1: 9000 4500 600 560 600 560 600 1700 600 1700 600\n2: 9020 4570 590 550 590 550 590 1640 590 1640 590\n\nOutput\n\nA: 9010 4535 595 555 595 555 595 1670 595 1670 595",
    "code": "def compare(p1, p2):\n   \"\"\"\n   Check that both recodings correspond in pulse length to within\n   TOLERANCE%.  If they do average the two recordings pulse lengths.\n\n   Input\n\n        M    S   M   S   M   S   M    S   M    S   M\n   1: 9000 4500 600 560 600 560 600 1700 600 1700 600\n   2: 9020 4570 590 550 590 550 590 1640 590 1640 590\n\n   Output\n\n   A: 9010 4535 595 555 595 555 595 1670 595 1670 595\n   \"\"\"\n   if len(p1) != len(p2):\n      return False\n\n   for i in range(len(p1)):\n      v = p1[i] / p2[i]\n      if (v < TOLER_MIN) or (v > TOLER_MAX):\n         return False\n\n   for i in range(len(p1)):\n       p1[i] = int(round((p1[i]+p2[i])/2.0))\n\n   if VERBOSE:\n      print(\"after compare\", p1)\n\n   return True"
  },
  {
    "type": "function",
    "name": "tidy_mark_space",
    "docstring": null,
    "code": "def tidy_mark_space(records, base):\n\n   ms = {}\n\n   # Find all the unique marks (base=0) or spaces (base=1)\n   # and count the number of times they appear,\n\n   for rec in records:\n      rl = len(records[rec])\n      for i in range(base, rl, 2):\n         if records[rec][i] in ms:\n            ms[records[rec][i]] += 1\n         else:\n            ms[records[rec][i]] = 1\n\n   if VERBOSE:\n      print(\"t_m_s A\", ms)\n\n   v = None\n\n   for plen in sorted(ms):\n\n      # Now go through in order, shortest first, and collapse\n      # pulses which are the same within a tolerance to the\n      # same value.  The value is the weighted average of the\n      # occurences.\n      #\n      # E.g. 500x20 550x30 600x30  1000x10 1100x10  1700x5 1750x5\n      #\n      # becomes 556(x80) 1050(x20) 1725(x10)\n      #\n      if v == None:\n         e = [plen]\n         v = plen\n         tot = plen * ms[plen]\n         similar = ms[plen]\n\n      elif plen < (v*TOLER_MAX):\n         e.append(plen)\n         tot += (plen * ms[plen])\n         similar += ms[plen]\n\n      else:\n         v = int(round(tot/float(similar)))\n         # set all previous to v\n         for i in e:\n            ms[i] = v\n         e = [plen]\n         v = plen\n         tot = plen * ms[plen]\n         similar = ms[plen]\n\n   v = int(round(tot/float(similar)))\n   # set all previous to v\n   for i in e:\n      ms[i] = v\n\n   if VERBOSE:\n      print(\"t_m_s B\", ms)\n\n   for rec in records:\n      rl = len(records[rec])\n      for i in range(base, rl, 2):\n         records[rec][i] = ms[records[rec][i]]"
  },
  {
    "type": "function",
    "name": "tidy",
    "docstring": null,
    "code": "def tidy(records):\n\n   tidy_mark_space(records, 0) # Marks.\n\n   tidy_mark_space(records, 1)"
  },
  {
    "type": "function",
    "name": "end_of_code",
    "docstring": null,
    "code": "def end_of_code():\n   global code, fetching_code\n   if len(code) > SHORT:\n      normalise(code)\n      fetching_code = False\n   else:\n      code = []\n      print(\"Short code, probably a repeat, try again\")"
  },
  {
    "type": "function",
    "name": "cbf",
    "docstring": null,
    "code": "def cbf(gpio, level, tick):\n\n   global last_tick, in_code, code, fetching_code\n\n   if level != pigpio.TIMEOUT:\n\n      edge = pigpio.tickDiff(last_tick, tick)\n      last_tick = tick\n\n      if fetching_code:\n\n         if (edge > PRE_US) and (not in_code): # Start of a code.\n            in_code = True\n            pi.set_watchdog(GPIO, POST_MS) # Start watchdog.\n\n         elif (edge > POST_US) and in_code: # End of a code.\n            in_code = False\n            pi.set_watchdog(GPIO, 0) # Cancel watchdog.\n            end_of_code()\n\n         elif in_code:\n            code.append(edge)\n\n   else:\n      pi.set_watchdog(GPIO, 0) # Cancel watchdog.\n      if in_code:\n         in_code = False\n         end_of_code()"
  },
  {
    "type": "function",
    "name": "get_status",
    "docstring": null,
    "code": "def get_status():\n  global status\n\n  with open('/var/lib/homebridge/node_modules/acDataHolder.json', 'r') as f:\n    contents = f.read()\n\n  if contents == '':\n    save_status()\n  else:\n    df = json.loads(contents)\n    for key, item in df.items():\n      status[key] = item\n\n    save_status()"
  },
  {
    "type": "function",
    "name": "set_status",
    "docstring": null,
    "code": "def set_status():\n  global status\n  chara = sys.argv[3]\n  value = float(sys.argv[4])\n\n  if chara == 'HeatingThresholdTemperature':\n    status['CurrentTemperature'] = status[chara]\n    if value > 30:\n      value = 30\n    elif value < 16:\n      value = 16\n  elif chara == 'CoolingThresholdTemperature':\n    status['CurrentTemperature'] = status[chara]\n    if value > 30:\n      value = 30\n    elif value < 16:\n      value = 16\n\n  elif chara == 'RotationSpeed':\n    if value < 10:\n      value = 0\n    elif value < 30:\n      value = 20\n    elif value < 50:\n      value = 40\n    elif value < 70:\n      value = 60\n    elif value < 90:\n      value = 80\n    else:\n      value = 100\n\n\n  value = math.ceil(value)\n\n  if status[chara] != value:\n    status[chara] = value\n\n    if status['Active'] == 1:\n      if status['TargetHeaterCoolerState'] == 1:\n        status['CurrentHeaterCoolerState'] = 2\n      elif status['TargetHeaterCoolerState'] == 2:\n        status['CurrentHeaterCoolerState'] = 3\n      else:\n        status['CurrentHeaterCoolerState'] = 1\n    else:\n      status['CurrentHeaterCoolerState'] = 0\n\n    save_status()\n    #ac_signal.send(status, chara)\n  try:\n    combined_arg = sys.argv[3] + \":\" + sys.argv[4]\n    subprocess.run(['python3', 'irrp.py', \"-p\", \"-g17\", \"-f\", \"codes\", combined_arg])\n  except:\n    pass"
  },
  {
    "type": "function",
    "name": "save_status",
    "docstring": null,
    "code": "def save_status():\n  global status\n  with open('/var/lib/homebridge/node_modules/acDataHolder.json', 'w') as f:\n    json.dump(status, f, indent=2)"
  },
  {
    "type": "function",
    "name": "test_get_command",
    "docstring": null,
    "code": "def test_get_command(capsys):\n    # Get コマンドのテスト\n    get_command('arg1', 'arg2')\n    captured = capsys.readouterr()\n    assert \"Get command executed with args: arg1 arg2\" in captured.out"
  },
  {
    "type": "function",
    "name": "test_set_light_on",
    "docstring": null,
    "code": "def test_set_light_on(mocker):\n    # subprocess.run をモック化\n    mock_subprocess = mocker.patch('subprocess.run')\n    \n    # ライトをオンにする場合のテスト\n    set_light_state(1)\n    mock_subprocess.assert_called_once_with(['python3', '/var/lib/homebridge/irrp.py', '-p', '-g17', '-f', 'codes', 'light:on'], check=True)"
  },
  {
    "type": "function",
    "name": "test_set_light_off",
    "docstring": null,
    "code": "def test_set_light_off(mocker):\n    # subprocess.run をモック化\n    mock_subprocess = mocker.patch('subprocess.run')\n    \n    # ライトをオフにする場合のテスト\n    set_light_state(0)\n    mock_subprocess.assert_called_once_with(['python3', '/var/lib/homebridge/irrp.py', '-p', '-g17', '-f', 'codes', 'light:off'], check=True)"
  },
  {
    "type": "function",
    "name": "test_invalid_light_state",
    "docstring": null,
    "code": "def test_invalid_light_state():\n    # 無効なライトの状態の場合のテスト\n    with pytest.raises(ValueError, match=\"Invalid light state. Use 0 to turn off or 1 to turn on.\"):\n        set_light_state(2)"
  }
]